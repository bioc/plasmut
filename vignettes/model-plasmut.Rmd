---
title: "Plasmut Model Results and Discussion"
output: html_document
---

```{r setup, include=FALSE}
library(plasmut)
library(tidyverse)
library(readxl)
library(ggmcmc)
library(rjags)
```


```{r data}

extdir <- system.file("extdata", package="plasmut")
fpath <- file.path(extdir, "cairo5-matched-sequencing.csv")

df <- read_csv(fpath, show_col_types=FALSE) %>% type.convert(as.is=TRUE)

data <- df %>% select(8:11) %>% magrittr::set_colnames(c("np", "yp", "nw", "yw")) %>% mutate(yw=ifelse(is.na(yw), 0, yw), nw = ifelse(is.na(nw), 1e8, nw)) %>% as.list()

```

We estimate the probability that a mutation identified from cfDNA analyses is somatic (tumor-derived) by first estimating the bayes factor and transforming that into a probability (bayes factor * prior odds then doing x / (1 + x)).

We estimate the bayes factor by finding the marginal likelihoods for somatic- and  hematopoietic-derived mutations.

M_s:   model that mutation is tumor derived.  If mutation is tumor derived, there could also be CTCs and non-zero MAFs in WBCs.

M_w:  model that mutation is derived from WBCs, whether germline or CH. There would be no CTCs with this mutation in model W.

theta_p: MAF of mutation in cfDNA

y_p: observed mutation frequency in cfDNA. n_p is total number of distinct reads at this position

theta_w: MAF of mutation from WBC sequencing.  Sequenced cells can be a mixture of WBCs and CTCs.

y_w: observed mutation frequency from WBC sequencing. n_w is total number of distinct reads at this position

## Model $M_s$

p(M_S | data) is the posterior probability of model S.  Using Bayes rule and ignoring the demoninator, we have

p(M_S | data) propto p(data | M_s) p(M_s)

The first term on the RHS is the marginal likelihood of the data under model S.  Referred to as marginal likelihood because there are no thetas.  Rewriting this term:

\begin{aligned}
p(data | M_s) &= \int_\theta p(data, \theta_w, \theta_p | M_s) d\theta\\
              &= \int_\theta p(data | \theta_w, \theta_p, M_s) p(\theta_w, \theta_p | M_s)d\theta\\
              &= \int_\theta p(y_p, n_p | \theta_p)p(y_w, n_w | \theta_w) p(\theta_w | M_s) p(\theta_p | M_s)d\theta
\end{aligned}

The overall level of a mutation in plasma may reflect the size of the tumor, vascularization, rate of cell turnover, whether mutation is clonal or subclonal and volume of blood.  While these same factors may influence the number of CTCs that are captured in the WBC sequencing, we assume a priori that theta_w and theta_s are independent.

Specification of priors $p(\theta_w | M_s)$ and $p(\theta_p | M_s)$:

\begin{aligned}
\theta_p | M_s &\sim \text{Beta}(1, 10)\\
\theta_w | M_s &= \omega \times Z ~\text{where}\\
\omega &\sim \text{Bernoulli}(10^{-3})\\
Z &\sim \text{Beta}(1, 10)
\end{aligned}

Monte Carlo approximation of $p(M_s | data)$:

1.  Obtain Monte Carlo samples of Z, $\omega$ and $\theta_p$ from their respective prior distributions
2.  Compute $\theta_w$
3.  Compute the likelihood of data for each $\theta_w$ and $\theta_p$ (the two likelihoods are each binomial)
4.  Multiply the likelihoods by the prior
5.  Approximate the integral by the mean

## Model $M_w$



While the coverage we see in plasma reflects chromatin structure and nucleosome positioning and possibly methylation, we assume that the numerator and denominator would be affected similarly.   With this assumption, whether a mutation is germline or CH the MAF in plasma cfDNA should be approximately the same as the MAF in sequenced WBCs. We assume that any differences in the empirical MAFs reflect sampling error.  Solving for the marginal likelihood, we have

\begin{aligned}
p(data | M_w) &= \int_\theta p(data, \theta | M_w) d\theta\\
              &= \int_\theta p(data | \theta) p(\theta | M_w)d\theta\\
              &= \int_\theta p(y_p, n_p, y_w, n_w | \theta)p(\theta | M_w)d\theta\\
              &= \int_\theta p(y_p, n_p | \theta) p(y_w, n_w | \theta) p(\theta| M_W) d\theta
\end{aligned}

Prior for $\theta$:

\begin{aligned}
\theta | M_w &\sim \text{Beta}(1, 10)
\end{aligned}

Monte Carlo approximation of $p(M_w | data)$

1. Obtain $\theta$ from its prior
2. Compute $p(\theta | M_w)$
3. Calculate the product of the two binomial likelihoods for the simulated $\theta$
4. Take the product of steps (2) and (3)

Steps 1-4 can be vectorized for a large Monte Carlo sample of $\theta$'s.

5. Approximate the integral by the mean

## Computing the Bayes factor

The Bayes factor is the ratio of the 2 marginal likelihoods that we've approximated by Monte Carlo:

\begin{align}
\text{Bayes factor} &= \frac{p(data | M_s)}{p(data|M_w)}\\
&\approx \frac{ \text{step 5 from } M_s}{\text{step 5 from }M_w}
\end{align}


```{r probabilities, eval=FALSE}

compute_p_somatic <- function(data, rho_ctc_parameter=0, a_w_somatic=1, b_w_somatic=10, a_p_somatic=1, b_p_somatic=10, a_theta=1, b_theta=10, prior.odds=1, chains=2, adapt=2000, iter=1e5, nthin=10){
  
  data$a_p <- a_p_somatic
  data$b_p <- b_p_somatic
  data$a_theta <- a_theta
  data$b_theta <- b_theta
  data$a_w <- a_w_somatic
  data$b_w <- b_w_somatic
  data$rho <- rho_ctc_parameter
  
  if (data$rho == 0){
    somatic_model <- system.file(file.path("JAGS", "somtic-model-no-tail.jag"), package = "plasmut", mustWork = TRUE)
  } else{
    somatic_model <- system.file(file.path("JAGS", "somatic-model.jag"), package = "plasmut", mustWork = TRUE)
  }
  
  hemato_model <- system.file(file.path("JAGS", "hemato-model.jag"), package="plasmut", mustWork = TRUE)

  #number of mutations to estimate probabilities for
  data$N <- length(data$np)

  fit.s <- rjags::jags.model(somatic_model, data=data, n.chains=chains, n.adapt=adapt)

  samples.s <- rjags::coda.samples(fit.s,
  	                         variable.names="out",
  	                          n.iter=iter,
  	                          thin=nthin)

  fit.h <- rjags::jags.model(hemato_model, data=data, n.chains=chains, n.adapt=adapt)

  samples.h <- rjags::coda.samples(fit.h,
  	                         variable.names="out",
  	                          n.iter=iter,
  	                          thin=nthin)

  somatic <- ggmcmc::ggs(samples.s) %>% filter(grepl("out", Parameter)) %>% group_by(Chain, Parameter) %>% summarize(v=mean(value)) %>% ungroup() %>% group_by(Parameter) %>% summarize(lik=mean(v))


  hemato <- ggmcmc::ggs(samples.h) %>% filter(grepl("out", Parameter)) %>% group_by(Chain, Parameter) %>% summarize(v=mean(value)) %>% ungroup() %>% group_by(Parameter) %>% summarize(lik=mean(v))

  bf <- somatic$lik / hemato$lik

  posterior.odds <- bf * prior.odds

  posterior.odds <- unlist(lapply(posterior.odds, function(x) ifelse(!is.finite(x), 1e100, x)))

  p <- posterior.odds / (1 + posterior.odds)

  return(list(bf=bf, p=p))
}

#no CTCs
no_ctc <- compute_p_somatic(data)

#CTCs
ctc <- compute_p_somatic(data, rho_ctc_parameter = 1e-3)
```


```{r wbc var type}
cols <- c("cfDNA distinct mutant reads",
          "cfDNA distinct reads",
          "wbc distinct mutant reads",
          "wbc distinct reads")

wbc.var.type <- stratify_wbc_vars(data=df,
                                  cols=cols)
```

```{r plotting}

df <- read_csv(fpath, show_col_types=FALSE) %>% type.convert(as.is=TRUE)


df <- df %>%
    mutate(prob.tumor.specific=ctc$p,
           wbc.var.type=wbc.var.type) %>%
    mutate(wbcmaf=`wbc distinct mutant reads`/`wbc distinct reads`,
           cfdnamaf=`cfDNA distinct mutant reads`/`cfDNA distinct reads`) %>%
    mutate(cfdnamaf=ifelse(is.nan(cfdnamaf), 0, cfdnamaf)) %>% filter(g_include=="yes")

df %>% select(cfdnamaf, wbcmaf, prob.tumor.specific, type) %>%
    filter(type=="Tumor-confirmed") %>%
    mutate(prob.tumor.specific = round(prob.tumor.specific, 3)) %>%
    group_by(prob.tumor.specific) %>%
    summarize(category=unique(type), n=n())

cluster.annotate <- df %>% select(wbc.var.type, cfdnamaf, wbcmaf) %>% group_by(wbc.var.type) %>% summarize(wbclevel=mean(wbcmaf)) %>% arrange(desc(wbclevel)) %>% filter(!is.na(wbc.var.type))

df <- df %>% mutate(status = wbc.var.type) %>% mutate(status = ifelse(is.na(status), "Likely tumor-specific", wbc.var.type)) %>% mutate(status = ifelse(status==cluster.annotate$wbc.var.type[1], "Germline variants", status)) %>% mutate(status = ifelse(status==cluster.annotate$wbc.var.type[2], "Hematopoietic variants", status)) %>% mutate(prob=status) %>% mutate(prob=ifelse(status=="Likely tumor-specific", prob.tumor.specific, prob)) %>% mutate(prob=ifelse(status=="Germline variants", 2, prob), prob=ifelse(status=="Hematopoietic variants", 0, prob)) %>% mutate(prob=as.numeric(prob))

df <- df %>% mutate(shapestatus=ifelse(type=="Tumor-confirmed", "Tumor confirmed", "Tumor not sequenced"))

cfvar_plot <- ggplot(df, aes(x=wbcmaf, y=cfdnamaf)) +
    geom_jitter(aes(color = prob, fill = status, shape=shapestatus),
                fill = "black", stat = "identity", lwd = 3, width = 0.1, alpha = 0.7) +
    scale_color_gradientn(colors = c("red3", "orange", "blue", "black", "black", "orange"),
                          na.value = "transparent",
                          breaks=c(0.6, 0.8, 1, 2, 0),
                          labels=c(0.6, 0.8, 1,"Germline variants", "Hematopoietic variants"),
                          limits=c(0 , 3)) +
    scale_x_continuous(labels = scales::percent_format(accuracy = 0.1),
                       breaks=c(0.000084, 0.001, 0.01,  0.1, 0.5),
                       trans='log10',
                       oob = scales::squish_infinite) +
    scale_y_continuous(labels = scales::percent_format(accuracy = 0.1),
                       breaks=c(0.000084, 0.001, 0.01,  0.1, 1),
                       trans='log10',
                       oob = scales::squish_infinite) +
    scale_shape_manual(values = c(17, 16)) +
    labs(x="White blood cell MAF (%)",
          y="cfDNA MAF (%)")+
    theme_bw() +
    theme(
      plot.background = element_blank(),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      plot.tag = element_text()) +
    theme(axis.line = element_line(color = 'black')) +
    theme(axis.text.x = element_text(vjust=1.2, hjust= 0.3)) +
    theme(legend.direction = "vertical", legend.box = "horizontal",
          legend.background = element_rect(fill = "transparent"),
          legend.position = c(0.47, 0.88),
          legend.key = element_rect(size = 5), #legend.box.background = element_rect(colour = "black"),
          legend.key.size = unit(0.4, "cm")) +
    guides(color=guide_legend(title="Probability\nTumor-Specific", nrow = 3),
           fill = guide_legend(title=""),
           shape = guide_legend(title="")) +
    geom_vline(xintercept=c(0.00015), linetype="dashed", size = 0.2) +
    geom_vline(xintercept=c(0.00009), linetype="dashed", size = 0.2, color = NA) +
    geom_vline(xintercept=c(0.25), linetype="dashed", size = 0.2) +
    geom_abline(slope=1, intercept=0, color="gray", alpha = 0.4, size = 0.4)

cfplot <- cfvar_plot + theme(axis.title=element_text(size=16), axis.text=element_text(size=13), legend.text=element_text(size=12), legend.title=element_text(size=14))

ggsave(filename="~/Downloads/cf-plasmut-ctc.pdf", plot=cfplot, device = cairo_pdf, width = 9, height = 9, units="in")
```

```{r sensitivity analysis rho parameter}
#change rho ctc parameter from 1:1000 to 1:100, correlations are 0.99 with bf and probabilities
df <- read_csv(fpath, show_col_types=FALSE) %>% type.convert(as.is=TRUE)

ctc_high_p <- compute_p_somatic(data, rho_ctc_parameter = 1e-2)

output <- df %>% mutate(prob=round(ctc$p, 3), bf=log(round(ctc$bf, 3)), prob.sens = round(ctc_high_p$p, 3), bf.sens = log(round(ctc_high_p$bf, 3))) %>% filter(g_include=="yes") %>% select(prob, prob.sens, bf, bf.sens)
    

output %>% select(bf, bf.sens) %>% filter(is.finite(bf)) %>% filter(is.finite(bf.sens)) %>% ggplot(aes(x=bf, y=bf.sens)) + geom_point()

ggplot(output, aes(x=prob, y=prob.sens)) +  theme_minimal() + geom_jitter(height=0.001, width=0.001) + geom_abline(slope=1, intercept=0, color="red", size=.3) + theme(axis.title=element_text(size=12)) + labs(x="CTC rho = 1:100 probs", y="CTC rho = 1:1000 probs")

output %>% select(bf, bf.sens) %>% filter(is.finite(bf)) %>% filter(is.finite(bf.sens)) %>% cor()
output %>% select(prob, prob.sens) %>% cor()

#change rho ctc parameter from 0 to 1e-8 and correlations are 0.99 very close together
df <- read_csv(fpath, show_col_types=FALSE) %>% type.convert(as.is=TRUE)

ctc_low_p <- compute_p_somatic(data, rho_ctc_parameter = 1e-8)

output <- df %>% mutate(prob=round(no_ctc$p, 3), bf=log(round(no_ctc$bf, 3)), prob.sens = round(ctc_low_p$p, 3), bf.sens = log(round(ctc_low_p$bf, 3))) %>% filter(g_include=="yes") %>% select(prob, prob.sens, bf, bf.sens)
    

output %>% select(bf, bf.sens) %>% filter(is.finite(bf)) %>% filter(is.finite(bf.sens)) %>% ggplot(aes(x=bf, y=bf.sens)) + geom_point()

ggplot(output, aes(x=prob, y=prob.sens)) +  theme_minimal() + geom_jitter(height=0.001, width=0.001) + geom_abline(slope=1, intercept=0, color="red", size=.3) + theme(axis.title=element_text(size=12)) + labs(x="CTC rho = 0 probs", y="CTC rho = 1:1e-8 probs")

output %>% select(bf, bf.sens) %>% filter(is.finite(bf)) %>% filter(is.finite(bf.sens)) %>% cor()
output %>% select(prob, prob.sens) %>% cor()

```


```{r sensitivity analysis beta parameters}


df <- read_csv(fpath, show_col_types=FALSE) %>% type.convert(as.is=TRUE)

beta_sens <- compute_p_somatic(data, 0, 1, 1, 1, 1, 1, 1, 1, 2, 2000, 1e5, 10)

output <- df %>% mutate(prob=round(no_ctc$p, 3), bf=log(round(no_ctc$bf, 3)), prob.sens = round(beta_sens$p, 3), bf.sens = log(round(beta_sens$bf, 3))) %>% filter(g_include=="yes") %>% select(prob, prob.sens, bf, bf.sens)
    
a <- output %>% select(bf, bf.sens) %>% filter(is.finite(bf)) %>% filter(is.finite(bf.sens)) %>% ggplot(aes(x=bf, y=bf.sens)) + theme_minimal() + geom_point(size=1) + geom_abline(slope=1, intercept=0, color="red", size=0.3) + theme(axis.title=element_text(size=12)) + labs(x="NO-CTC beta (1,10) bf", y="NO-CTC beta (1,1) bf")

b <- ggplot(output, aes(x=prob, y=prob.sens)) +  theme_minimal() + geom_jitter(height=0.001, width=0.001) + geom_abline(slope=1, intercept=0, color="red", size=.3) + theme(axis.title=element_text(size=12)) + labs(x="NO-CTC beta (1,10) prob", y="NO-CTC beta (1,1) prob")

cowplot::plot_grid(a,b, nrow=1, labels=NULL)

output %>% select(bf, bf.sens) %>% filter(is.finite(bf)) %>% filter(is.finite(bf.sens)) %>% cor()
output %>% select(prob, prob.sens) %>% cor()

```

```{r NO CTC model, eval=FALSE}
#no_ctc(theta_w = 0 in somatic; theta_p = theta_w in hematopoietic) with prior model implemented in bayesian framework
#Results are consistent with simulation in R method.
#There are 5 mutations for which the p(somatic) < 0.9 and they are given an assignment label as likely tumor by Jamie et. al.
#All 4 CTCs have probability of tumor derived  = 0

df %>% mutate(prob.tumor.specific=no_ctc$p) %>% mutate(wbcmaf=`wbc distinct mutant reads`/`wbc distinct reads`, cfdnamaf=`cfDNA distinct mutant reads`/`cfDNA distinct reads`) %>% mutate(cfdnamaf=ifelse(is.nan(cfdnamaf), 0, cfdnamaf))  %>% select(Gene, Patient, prob.tumor.specific, cfdnamaf, wbcmaf, `wbc distinct mutant reads`,`wbc distinct reads`,`cfDNA distinct mutant reads`,`cfDNA distinct reads`, type, g_include) %>% filter((g_include == "yes" | type == "Circulating Tumor Cell")) %>% filter(prob.tumor.specific < 0.9) %>% filter(prob.tumor.specific > 0) %>% mutate(prob.tumor.specific = round(prob.tumor.specific, 3)) %>% arrange(prob.tumor.specific) %>% as.data.frame()

```

```{r CTC model, eval=FALSE}
#3 CTCs have prob 1
#all wbc variants have probability of tumor derived less than or equal to 3e-5 so basically zero
df %>% mutate(prob.tumor.specific=ctc$p) %>% mutate(wbcmaf=`wbc distinct mutant reads`/`wbc distinct reads`, cfdnamaf=`cfDNA distinct mutant reads`/`cfDNA distinct reads`) %>% mutate(cfdnamaf=ifelse(is.nan(cfdnamaf), 0, cfdnamaf))  %>% select(Gene, Patient, prob.tumor.specific, cfdnamaf, wbcmaf, `wbc distinct mutant reads`,`wbc distinct reads`,`cfDNA distinct mutant reads`,`cfDNA distinct reads`, type, g_include) %>% filter((g_include == "yes" | type == "Circulating Tumor Cell")) %>% filter(prob.tumor.specific < 0.9) %>% filter(prob.tumor.specific > 0) %>% arrange(desc(prob.tumor.specific)) %>% mutate(prob.tumor.specific = round(prob.tumor.specific, 3)) %>% as.data.frame()
```
